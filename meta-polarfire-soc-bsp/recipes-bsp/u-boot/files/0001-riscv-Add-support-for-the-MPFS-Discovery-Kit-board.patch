From 7b9d48bc7ef4b98cbe51eba2da3dc3c65300dd72 Mon Sep 17 00:00:00 2001
From: Pierre-Henry Moussay <ph.moussay.dev@gmail.com>
Date: Wed, 14 Feb 2024 12:56:14 +0000
Subject: [PATCH] riscv: Add support for the MPFS Discovery Kit board support

The MPFS Discovery Kit (PolarFire SoC Discovery Kit) is a
compact SoC prototyping board featuring a Microchip PolarFire SoC
MPFS095T-1FCSG325E. Features include:
 - 1 GB DDR4 SDRAM
 - Gigabit Ethernet
 - microSD-card slot

Signed-off-by: Pierre-Henry Moussay <ph.moussay.dev@gmail.com>
---
 arch/riscv/Kconfig                            |   4 +
 arch/riscv/dts/Makefile                       |   1 +
 .../dts/microchip-mpfs-disco-kit-u-boot.dtsi  |  14 +
 arch/riscv/dts/microchip-mpfs-disco-kit.dts   | 166 ++++++++
 board/microchip/mpfs_discokit/Kconfig         |  44 +++
 board/microchip/mpfs_discokit/MAINTAINERS     |   7 +
 board/microchip/mpfs_discokit/Makefile        |   7 +
 board/microchip/mpfs_discokit/mpfs_discokit.c | 371 ++++++++++++++++++
 configs/microchip_mpfs_discokit_defconfig     |  30 ++
 include/configs/microchip_mpfs_discokit.h     |  73 ++++
 10 files changed, 717 insertions(+)
 create mode 100644 arch/riscv/dts/microchip-mpfs-disco-kit-u-boot.dtsi
 create mode 100644 arch/riscv/dts/microchip-mpfs-disco-kit.dts
 create mode 100644 board/microchip/mpfs_discokit/Kconfig
 create mode 100644 board/microchip/mpfs_discokit/MAINTAINERS
 create mode 100644 board/microchip/mpfs_discokit/Makefile
 create mode 100644 board/microchip/mpfs_discokit/mpfs_discokit.c
 create mode 100644 configs/microchip_mpfs_discokit_defconfig
 create mode 100644 include/configs/microchip_mpfs_discokit.h

diff --git a/arch/riscv/Kconfig b/arch/riscv/Kconfig
index cf3ec85624..8892a0e870 100644
--- a/arch/riscv/Kconfig
+++ b/arch/riscv/Kconfig
@@ -20,6 +20,9 @@ config TARGET_BEAGLEBOARD_BEAGLEVFIRE
 config TARGET_MICROCHIP_ICICLE
       bool "Support Microchip PolarFire-SoC Icicle Board"

+config TARGET_MICROCHIP_DISCOKIT
+      bool "Support Microchip PolarFire-SoC Discovery Board"
+
 config TARGET_MICROCHIP_VIDEOKIT
       bool "Support Microchip PolarFire-SoC Video Kit"

@@ -82,6 +85,7 @@ source "board/aries/m100pfsevp/Kconfig"
 source "board/beagle/beaglev_fire/Kconfig"
 source "board/emulation/qemu-riscv/Kconfig"
 source "board/microchip/mpfs_icicle/Kconfig"
+source "board/microchip/mpfs_discokit/Kconfig"
 source "board/microchip/mpfs_videokit/Kconfig"
 source "board/sundancedsp/polarberry/Kconfig"
 source "board/sifive/unleashed/Kconfig"
diff --git a/arch/riscv/dts/Makefile b/arch/riscv/dts/Makefile
index 6a420aeef9..287034676a 100644
--- a/arch/riscv/dts/Makefile
+++ b/arch/riscv/dts/Makefile
@@ -6,6 +6,7 @@ dtb-$(CONFIG_TARGET_ARIES_M100PFSEVP) += mpfs-m100pfsevp.dtb
 dtb-$(CONFIG_TARGET_BEAGLEBOARD_BEAGLEVFIRE) += mpfs-beaglev-fire.dtb
 dtb-$(CONFIG_TARGET_MICROCHIP_ICICLE) += microchip-mpfs-icicle-kit.dtb \
 microchip-mpfs-icicle-kit-amp.dtb microchip-mpfs-icicle-kit-qspi-nor.dtb
+dtb-$(CONFIG_TARGET_MICROCHIP_DISCOKIT) += microchip-mpfs-disco-kit.dtb
 dtb-$(CONFIG_TARGET_MICROCHIP_VIDEOKIT) += microchip-mpfs-video-kit.dtb
 dtb-$(CONFIG_TARGET_SUNDANCEDSP_POLARBERRY) += mpfs-polarberry.dtb
 dtb-$(CONFIG_TARGET_QEMU_VIRT) += qemu-virt32.dtb qemu-virt64.dtb
diff --git a/arch/riscv/dts/microchip-mpfs-disco-kit-u-boot.dtsi b/arch/riscv/dts/microchip-mpfs-disco-kit-u-boot.dtsi
new file mode 100644
index 0000000000..f60283fb6b
--- /dev/null
+++ b/arch/riscv/dts/microchip-mpfs-disco-kit-u-boot.dtsi
@@ -0,0 +1,14 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/*
+ * Copyright (C) 2020 Microchip Technology Inc.
+ * Padmarao Begari <padmarao.begari@microchip.com>
+ */
+
+/ {
+      aliases {
+              cpu1 = &cpu1;
+              cpu2 = &cpu2;
+              cpu3 = &cpu3;
+              cpu4 = &cpu4;
+      };
+};
diff --git a/arch/riscv/dts/microchip-mpfs-disco-kit.dts b/arch/riscv/dts/microchip-mpfs-disco-kit.dts
new file mode 100644
index 0000000000..8962dc53ec
--- /dev/null
+++ b/arch/riscv/dts/microchip-mpfs-disco-kit.dts
@@ -0,0 +1,166 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (C) 2024 Microchip Technology Inc.
+ * Padmarao Begari <padmarao.begari@microchip.com>
+ */
+
+/dts-v1/;
+
+#include "microchip-mpfs.dtsi"
+
+/* Clock frequency (in Hz) of the rtcclk */
+#define RTCCLK_FREQ           1000000
+
+/ {
+      model = "Microchip PolarFire-SoC Discovery Kit";
+      compatible = "microchip,mpfs-disco-kit", "microchip,mpfs";
+
+      aliases {
+              serial4 = &uart4;
+              ethernet0 = &mac0;
+      };
+
+      chosen {
+              stdout-path = "serial4";
+      };
+
+      cpus {
+              timebase-frequency = <RTCCLK_FREQ>;
+      };
+
+      ddr_cached_low: memory@80000000 {
+              device_type = "memory";
+              reg = <0x0 0x80000000 0x0 0x40000000>;
+              label = "kernel";
+      };
+
+      ddr_non_cached_low: memory@c4000000 {
+              device_type = "memory";
+              reg = <0x0 0xc4000000 0x0 0x6000000>;
+              label = "non-cached-low";
+      };
+
+      ddr_cached_high: memory@1022000000 {
+              device_type = "memory";
+              reg = <0x10 0x22000000 0x0 0x1e000000>;
+              label = "cached-high";
+      };
+
+      ddr_non_cached_high: memory@1412000000 {
+              device_type = "memory";
+              reg = <0x14 0x12000000 0x0 0x10000000>;
+              label = "non-cached-high";
+      };
+
+      reserved-memory {
+              #address-cells = <2>;
+              #size-cells = <2>;
+              ranges;
+
+              hss: hss-buffer {
+                      compatible = "shared-dma-pool";
+                      reg = <0x10 0x3fc00000 0x0 0x400000>;
+                      no-map;
+              };
+
+              dma_non_cached_low: non-cached-low-buffer {
+                      compatible = "shared-dma-pool";
+                      size = <0x0 0x4000000>;
+                      no-map;
+                      linux,dma-default;
+                      alloc-ranges = <0x0 0xc4000000 0x0 0x4000000>;
+                      dma-ranges = <0x0 0xc4000000 0x0 0xc4000000 0x0 0x4000000>;
+              };
+
+              dma_non_cached_high: non-cached-high-buffer {
+                      compatible = "shared-dma-pool";
+                      size = <0x0 0x10000000>;
+                      no-map;
+                      linux,dma-default;
+                      alloc-ranges = <0x14 0x12000000 0x0 0x10000000>;
+                      dma-ranges = <0x14 0x12000000 0x14 0x12000000 0x0 0x10000000>;
+              };
+
+              fabricbuf0ddrc: buffer@88000000 {
+                      compatible = "shared-dma-pool";
+                      reg = <0x0 0x88000000 0x0 0x2000000>;
+                      no-map;
+              };
+
+              fabricbuf1ddrnc: buffer@c8000000 {
+                      compatible = "shared-dma-pool";
+                      reg = <0x0 0xc8000000 0x0 0x2000000>;
+                      no-map;
+              };
+
+              fabricbuf2ddrncwcb: buffer@d8000000 {
+                      compatible = "shared-dma-pool";
+                      reg = <0x0 0xd8000000 0x0 0x2000000>;
+                      no-map;
+              };
+
+              non_cached: region@84000000 {
+                      reg = <0x0 0x84000000 0x0 0x4000000>;
+                      no-map;
+              };
+      };
+
+      udmabuf0 {
+              compatible = "ikwzm,u-dma-buf";
+              device-name = "udmabuf-ddr-c0";
+              minor-number = <0>;
+              size = <0x0 0x2000000>;
+              memory-region = <&fabricbuf0ddrc>;
+              sync-mode = <3>;
+      };
+
+      udmabuf1 {
+              compatible = "ikwzm,u-dma-buf";
+              device-name = "udmabuf-ddr-nc0";
+              minor-number = <1>;
+              size = <0x0 0x2000000>;
+              memory-region = <&fabricbuf1ddrnc>;
+              sync-mode = <3>;
+      };
+
+      udmabuf2 {
+              compatible = "ikwzm,u-dma-buf";
+              device-name = "udmabuf-ddr-nc-wcb0";
+              minor-number = <2>;
+              size = <0x0 0x2000000>;
+              memory-region = <&fabricbuf2ddrncwcb>;
+              sync-mode = <3>;
+      };
+};
+
+&refclk {
+      clock-frequency = <125000000>;
+};
+
+&uart4 {
+      status = "okay";
+};
+
+&mmc {
+      status = "okay";
+      bus-width = <4>;
+      disable-wp;
+      cap-mmc-highspeed;
+      cap-sd-highspeed;
+      card-detect-delay = <200>;
+      mmc-ddr-1_8v;
+      mmc-hs200-1_8v;
+      sd-uhs-sdr12;
+      sd-uhs-sdr25;
+      sd-uhs-sdr50;
+      sd-uhs-sdr104;
+};
+
+&mac0 {
+      status = "okay";
+      phy-mode = "sgmii";
+      phy-handle = <&phy0>;
+      phy0: ethernet-phy@11 {
+              reg = <11>;
+      };
+};
diff --git a/board/microchip/mpfs_discokit/Kconfig b/board/microchip/mpfs_discokit/Kconfig
new file mode 100644
index 0000000000..e3167e0c09
--- /dev/null
+++ b/board/microchip/mpfs_discokit/Kconfig
@@ -0,0 +1,44 @@
+if TARGET_MICROCHIP_DISCOKIT
+
+config SYS_BOARD
+      default "mpfs_discokit"
+
+config SYS_VENDOR
+      default "microchip"
+
+config SYS_CPU
+      default "mpfs"
+
+config SYS_CONFIG_NAME
+      default "microchip_mpfs_discokit"
+
+config TEXT_BASE
+      default 0x80000000 if !RISCV_SMODE
+      default 0x80200000 if RISCV_SMODE
+
+config BOARD_SPECIFIC_OPTIONS # dummy
+      def_bool y
+      select MICROCHIP_MPFS
+      select BOARD_EARLY_INIT_F
+      select BOARD_LATE_INIT
+      imply SMP
+      imply CMD_DHCP
+      imply CMD_EXT2
+      imply CMD_EXT4
+      imply CMD_FAT
+      imply CMD_FS_GENERIC
+      imply CMD_NET
+      imply CMD_PING
+      imply CMD_MMC
+      imply DOS_PARTITION
+      imply EFI_PARTITION
+      imply IP_DYN
+      imply ISO_PARTITION
+      imply PHY_LIB
+      imply PHY_VITESSE
+      imply MTD_SPI_NAND
+      imply CMD_MTD
+      imply MTD_PARTITIONS
+      imply CMD_MTDPARTS
+      imply MPFS_PRIORITISE_QSPI_BOOT
+endif
diff --git a/board/microchip/mpfs_discokit/MAINTAINERS b/board/microchip/mpfs_discokit/MAINTAINERS
new file mode 100644
index 0000000000..e83b7a8841
--- /dev/null
+++ b/board/microchip/mpfs_discokit/MAINTAINERS
@@ -0,0 +1,7 @@
+Microchip MPFS disco-kit
+M:    Padmarao Begari <padmarao.begari@microchip.com>
+M:    Cyril Jean <cyril.jean@microchip.com>
+S:    Maintained
+F:    board/microchip/mpfs_discokit/
+F:    include/configs/microchip_mpfs_discokit.h
+F:    configs/microchip_mpfs_discokit_defconfig
diff --git a/board/microchip/mpfs_discokit/Makefile b/board/microchip/mpfs_discokit/Makefile
new file mode 100644
index 0000000000..39862ca1e5
--- /dev/null
+++ b/board/microchip/mpfs_discokit/Makefile
@@ -0,0 +1,7 @@
+# SPDX-License-Identifier: GPL-2.0+
+#
+# Copyright (C) 2019 Microchip Technology Inc.
+# Padmarao Begari <padmarao.begari@microchip.com>
+#
+
+obj-y += mpfs_discokit.o
diff --git a/board/microchip/mpfs_discokit/mpfs_discokit.c b/board/microchip/mpfs_discokit/mpfs_discokit.c
new file mode 100644
index 0000000000..99c6856db2
--- /dev/null
+++ b/board/microchip/mpfs_discokit/mpfs_discokit.c
@@ -0,0 +1,371 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2019-2023 Microchip Technology Inc.
+ * Padmarao Begari <padmarao.begari@microchip.com>
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <env.h>
+#include <init.h>
+#include <malloc.h>
+#include <asm/global_data.h>
+#include <asm/io.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define MPFS_SYSREG_SOFT_RESET                ((unsigned int *)0x20002088)
+#define MPFS_SYS_SERVICE_CR           ((unsigned int *)0x37020050)
+#define MPFS_SYS_SERVICE_SR           ((unsigned int *)0x37020054)
+#define MPFS_SYS_SERVICE_MAILBOX_U8   ((unsigned char *)0x37020800)
+#define MPFS_SYS_SERVICE_MAILBOX_U32  ((unsigned int *)0x37020800)
+
+#define SERVICE_CR_REQ_MASK           0x1u
+#define SERVICE_SR_BUSY_MASK          0x2u
+#define SERVICE_SR_STATUS_SHIFT               16
+#define SERVICE_CR_COMMAND_SHIFT      16
+
+#define SYS_SPI_CMD                   0x50
+#define SYS_SPI_MAILBOX_DATA_LEN      17
+#define SYS_SPI_MAILBOX_SRC_OFFSET    8
+#define SYS_SPI_MAILBOX_LENGTH_OFFSET 12
+#define SYS_SPI_MAILBOX_FREQ_OFFSET   16
+#define SYS_SPI_MAILBOX_FREQ          3
+#define SPI_FLASH_ADDR                        0x400
+
+#define PERIPH_RESET_VALUE            0x800001e8u
+
+/* Descriptor table */
+#define START_OFFSET                  4
+#define END_OFFSET                    8
+#define SIZE_OFFSET                   12
+#define DESC_NEXT                     12
+#define DESC_RESERVED_SIZE            0
+#define DESC_SIZE                     16
+
+#define BYTES_2                               2
+#define BYTES_4                               4
+#define BYTES_8                               8
+#define BYTES_16                      16
+#define BYTES_24                      24
+#define MASK_8BIT                     0xff
+
+#define DESIGN_MAGIC_0                        0x4d /* 'M' */
+#define DESIGN_MAGIC_1                        0x43 /* 'C'*/
+#define DESIGN_MAGIC_2                        0x48 /* 'H'*/
+#define DESIGN_MAGIC_3                        0x50 /* 'P'*/
+
+static u8 no_of_dtbo;
+static u32 dtbos_size;
+
+static void read_device_serial_number(u8 *response, u8 response_size)
+{
+      u8 idx;
+      u8 *response_buf;
+      unsigned int val;
+
+      response_buf = (u8 *)response;
+
+      writel(SERVICE_CR_REQ_MASK, MPFS_SYS_SERVICE_CR);
+      /*
+       * REQ bit will remain set till the system controller starts
+       * processing.
+       */
+      do {
+              val = readl(MPFS_SYS_SERVICE_CR);
+      } while (SERVICE_CR_REQ_MASK == (val & SERVICE_CR_REQ_MASK));
+
+      /*
+       * Once system controller starts processing the busy bit will
+       * go high and service is completed when busy bit is gone low
+       */
+      do {
+              val = readl(MPFS_SYS_SERVICE_SR);
+      } while (SERVICE_SR_BUSY_MASK == (val & SERVICE_SR_BUSY_MASK));
+
+      for (idx = 0; idx < response_size; idx++)
+              response_buf[idx] = readb(MPFS_SYS_SERVICE_MAILBOX_U8 + idx);
+}
+
+static u16 execute_sys_service(u8 cmd_opcode, u8 *cmd_data, u16 cmd_data_size)
+{
+      u32 *word_buf;
+      u32 mailbox_val;
+      u32 idx, value;
+      u16 status;
+      u8 *byte_buf;
+      u8 byte_offset;
+      u8 byte_idx;
+
+      word_buf = (u32 *)cmd_data;
+
+      for (idx = 0; idx < cmd_data_size / BYTES_4; idx++)
+              writel(word_buf[idx], MPFS_SYS_SERVICE_MAILBOX_U32 + idx);
+
+      if (cmd_data_size % BYTES_4 > 0) {
+              byte_offset = (cmd_data_size / BYTES_4) * BYTES_4;
+              byte_buf = (u8 *)(cmd_data + byte_offset);
+
+              mailbox_val = readl(MPFS_SYS_SERVICE_MAILBOX_U32 + idx);
+
+              for (byte_idx = 0; byte_idx < cmd_data_size % 4; byte_idx++) {
+                      mailbox_val &= ~(MASK_8BIT << (byte_idx * BYTES_8));
+                      value = byte_buf[byte_idx] << (byte_idx * BYTES_8);
+                      mailbox_val |= value;
+              }
+              writel(mailbox_val, MPFS_SYS_SERVICE_MAILBOX_U32 + idx);
+      }
+
+      writel((cmd_opcode << SERVICE_CR_COMMAND_SHIFT) | SERVICE_CR_REQ_MASK,
+             MPFS_SYS_SERVICE_CR);
+
+      /*
+       * REQ bit will remain set till the system controller starts
+       * processing.
+       */
+      do {
+              value = readl(MPFS_SYS_SERVICE_CR);
+      } while (SERVICE_CR_REQ_MASK == (value & SERVICE_CR_REQ_MASK));
+
+      /*
+       * Once system controller starts processing the busy bit will
+       * go high and service is completed when busy bit is gone low
+       */
+      do {
+              value = readl(MPFS_SYS_SERVICE_SR);
+      } while (SERVICE_SR_BUSY_MASK == (value & SERVICE_SR_BUSY_MASK));
+
+      status = value >> SERVICE_SR_STATUS_SHIFT;
+
+      return status;
+}
+
+static u16 sys_service_spi_copy(void *dst_addr, u32 src_addr, u32 length)
+{
+      u16 status;
+      u8 mailbox_format[SYS_SPI_MAILBOX_DATA_LEN];
+
+      *(u64 *)mailbox_format = (u64)dst_addr;
+      *(u32 *)(mailbox_format + SYS_SPI_MAILBOX_SRC_OFFSET) = src_addr;
+      *(u32 *)(mailbox_format + SYS_SPI_MAILBOX_LENGTH_OFFSET) = length;
+      mailbox_format[SYS_SPI_MAILBOX_FREQ_OFFSET] = SYS_SPI_MAILBOX_FREQ;
+
+      status = execute_sys_service(SYS_SPI_CMD, mailbox_format,
+                                   SYS_SPI_MAILBOX_DATA_LEN);
+      return status;
+}
+
+static u16 get_dtbo_desc_header(u8 *desc_data, u32 desc_addr)
+{
+      u32 length, no_of_descs;
+      u16 status;
+
+      /* Get first four bytes to calculate length */
+      status = sys_service_spi_copy(desc_data, desc_addr, BYTES_4);
+      if (!status) {
+              /* Number of descriptors in dtbo descriptor */
+              no_of_descs = *((u32 *)desc_data);
+              if (no_of_descs) {
+                      length = DESC_SIZE + ((no_of_descs - 1) * DESC_SIZE);
+                      status = sys_service_spi_copy(desc_data, desc_addr,
+                                                    length);
+              } else {
+                      status = -1;
+              }
+      }
+
+      return status;
+}
+
+static u8 *get_dtbo(u32 start_addr, u32 size)
+{
+      u16 status;
+      u8 *dtbo;
+
+      dtbo = (u8 *)malloc(size);
+      /* Get a dtbo from the spi flash */
+      status = sys_service_spi_copy(dtbo, start_addr + SPI_FLASH_ADDR,
+                                    size);
+      if (status) {
+              free(dtbo);
+              dtbo = NULL;
+      }
+
+      return dtbo;
+}
+
+static void parse_desc_header(u8 *desc_header)
+{
+      u32 dtbo_desc_start_addr;
+      u32 dtbo_desc_end_addr;
+      u32 dtbo_desc_size;
+      u32 no_of_descs;
+      u16 idx, rsvd = 0;
+      u8 dtbo_name[16];
+      u8 dtbo_addr[20];
+      u8 *desc;
+      u8 *dtbo;
+
+      no_of_descs = *((u32 *)desc_header);
+
+      for (idx = 0; idx < no_of_descs; idx++) {
+              desc = &desc_header[START_OFFSET + (DESC_NEXT * idx) + rsvd];
+              dtbo_desc_start_addr = *((u32 *)desc);
+
+              desc = &desc_header[END_OFFSET + (DESC_NEXT * idx) + rsvd];
+              dtbo_desc_end_addr = *((u32 *)desc);
+
+              desc = &desc_header[SIZE_OFFSET + (DESC_NEXT * idx) + rsvd];
+              dtbo_desc_size = *((u32 *)desc);
+
+              if (no_of_descs)
+                      rsvd += DESC_RESERVED_SIZE;
+
+              dtbo = get_dtbo(dtbo_desc_start_addr, dtbo_desc_size);
+              if (dtbo) {
+                      sprintf(dtbo_name, "dtbo_image%d", no_of_dtbo);
+                      sprintf(dtbo_addr, "0x%llx", (u64)dtbo);
+                      env_set(dtbo_name, dtbo_addr);
+                      ++no_of_dtbo;
+                      dtbos_size += dtbo_desc_size;
+              }
+      }
+}
+
+static void get_device_tree_overlays(void)
+{
+      u32 desc_length;
+      u32 dtbo_desc_addr;
+      u32 dtbo_addr[5];
+      u16 i, status, hart, no_of_harts;
+      u8 design_info_desc[256];
+      u8 dtbo_desc_data[256];
+      u8 no_of_dtbos[8];
+      u8 dtbo_size[8];
+      u8 *desc;
+
+      no_of_dtbo = 0;
+      dtbos_size = 0;
+
+      /* Read first 10 bytes to verify the descriptor is found or not */
+      status = sys_service_spi_copy(design_info_desc, SPI_FLASH_ADDR, 10);
+
+      if (!status && design_info_desc[0] == DESIGN_MAGIC_0 &&
+          design_info_desc[1] == DESIGN_MAGIC_1 &&
+          design_info_desc[2] == DESIGN_MAGIC_2 &&
+          design_info_desc[3] == DESIGN_MAGIC_3) {
+              desc_length = *((u32 *)&design_info_desc[4]);
+              /* Read Design descriptor */
+              status = sys_service_spi_copy(design_info_desc,
+                                            SPI_FLASH_ADDR, desc_length);
+              if (!status) {
+                      no_of_harts = *((u16 *)&design_info_desc[10]);
+
+                      for (hart = 0; hart < no_of_harts; hart++) {
+                              /* Start address of DTBO descriptor */
+                              desc = &design_info_desc[(0x4 * hart) + 0xc];
+
+                              dtbo_desc_addr = *((u32 *)desc);
+                              dtbo_addr[hart] = dtbo_desc_addr;
+
+                              if (!dtbo_addr[hart])
+                                      continue;
+
+                              for (i = 0; i < hart; i++) {
+                                      if (dtbo_addr[hart] == dtbo_addr[i])
+                                              continue;
+                              }
+
+                              if (hart && hart == i)
+                                      continue;
+
+                              dtbo_desc_addr += SPI_FLASH_ADDR;
+                              status = get_dtbo_desc_header(dtbo_desc_data,
+                                                            dtbo_desc_addr);
+                              if (status)
+                                      continue;
+                              else
+                                      parse_desc_header(dtbo_desc_data);
+                      }
+              }
+      }
+      sprintf(no_of_dtbos, "%d", no_of_dtbo);
+      env_set("no_of_overlays", no_of_dtbos);
+      sprintf(dtbo_size, "%d", dtbos_size);
+      env_set("dtbo_size", dtbo_size);
+}
+
+int board_init(void)
+{
+      /* For now nothing to do here. */
+
+      return 0;
+}
+
+int board_early_init_f(void)
+{
+      unsigned int val;
+
+      /* Reset uart, mmc peripheral */
+      val = readl(MPFS_SYSREG_SOFT_RESET);
+      val = (val & ~(PERIPH_RESET_VALUE));
+      writel(val, MPFS_SYSREG_SOFT_RESET);
+
+      return 0;
+}
+
+int board_late_init(void)
+{
+      u32 ret;
+      u32 node;
+      u8 idx;
+      u8 device_serial_number[16] = { 0 };
+      unsigned char mac_addr[6];
+      char discokit_mac_addr[20];
+      void *blob = (void *)gd->fdt_blob;
+
+      node = fdt_path_offset(blob, "ethernet0");
+      if (node < 0) {
+              printf("No ethernet0 path offset\n");
+              return -ENODEV;
+      }
+
+      ret = fdtdec_get_byte_array(blob, node, "local-mac-address", mac_addr, 6);
+      if (ret) {
+              printf("No local-mac-address property\n");
+              return -EINVAL;
+      }
+
+      read_device_serial_number(device_serial_number, 16);
+
+      /* Update MAC address with device serial number */
+      mac_addr[0] = 0x00;
+      mac_addr[1] = 0x04;
+      mac_addr[2] = 0xA3;
+      mac_addr[3] = device_serial_number[2];
+      mac_addr[4] = device_serial_number[1];
+      mac_addr[5] = device_serial_number[0];
+
+      ret = fdt_setprop(blob, node, "local-mac-address", mac_addr, 6);
+      if (ret) {
+              printf("Error setting local-mac-address property\n");
+              return -ENODEV;
+      }
+
+      discokit_mac_addr[0] = '[';
+
+      sprintf(&discokit_mac_addr[1], "%pM", mac_addr);
+
+      discokit_mac_addr[18] = ']';
+      discokit_mac_addr[19] = '\0';
+
+      for (idx = 0; idx < 20; idx++) {
+              if (discokit_mac_addr[idx] == ':')
+                      discokit_mac_addr[idx] = ' ';
+      }
+      env_set("discokit_mac_addr0", discokit_mac_addr);
+
+      get_device_tree_overlays();
+
+      return 0;
+}
diff --git a/configs/microchip_mpfs_discokit_defconfig b/configs/microchip_mpfs_discokit_defconfig
new file mode 100644
index 0000000000..3496e14fc0
--- /dev/null
+++ b/configs/microchip_mpfs_discokit_defconfig
@@ -0,0 +1,30 @@
+CONFIG_RISCV=y
+CONFIG_SYS_MALLOC_LEN=0x800000
+CONFIG_SYS_MALLOC_F_LEN=0x2000
+CONFIG_HAS_CUSTOM_SYS_INIT_SP_ADDR=y
+CONFIG_CUSTOM_SYS_INIT_SP_ADDR=0x80200000
+CONFIG_ENV_SIZE=0x2000
+CONFIG_DEFAULT_DEVICE_TREE="microchip-mpfs-disco-kit"
+CONFIG_SYS_PROMPT="RISC-V # "
+CONFIG_SYS_LOAD_ADDR=0x80200000
+CONFIG_TARGET_MICROCHIP_DISCOKIT=y
+CONFIG_ARCH_RV64I=y
+CONFIG_RISCV_SMODE=y
+CONFIG_FIT=y
+CONFIG_DISTRO_DEFAULTS=y
+CONFIG_DISPLAY_CPUINFO=y
+CONFIG_DISPLAY_BOARDINFO=y
+CONFIG_SYS_CBSIZE=256
+CONFIG_SYS_PBSIZE=282
+CONFIG_SYS_BOOTM_LEN=0x4000000
+CONFIG_SYS_RELOC_GD_ENV_ADDR=y
+CONFIG_BOOTP_SEND_HOSTNAME=y
+CONFIG_DM_MTD=y
+CONFIG_SYSRESET=y
+CONFIG_CMD_MTDPARTS=y
+CONFIG_MTDPARTS_DEFAULT="mtdparts=spi-nand0:2m(payload),128k(env),119m(rootfs)"
+CONFIG_CMD_UBI=y
+CONFIG_CMD_UBIFS=y
+CONFIG_MTD_UBI_WL_THRESHOLD=4096
+CONFIG_MTD_UBI_BEB_LIMIT=20
+CONFIG_OF_LIBFDT_OVERLAY=y
\ No newline at end of file
diff --git a/include/configs/microchip_mpfs_discokit.h b/include/configs/microchip_mpfs_discokit.h
new file mode 100644
index 0000000000..43b04e66c3
--- /dev/null
+++ b/include/configs/microchip_mpfs_discokit.h
@@ -0,0 +1,73 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright (C) 2019 Microchip Technology Inc.
+ * Padmarao Begari <padmarao.begari@microchip.com>
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <linux/sizes.h>
+
+#define CFG_SYS_SDRAM_BASE       0x80000000
+
+/* Environment options */
+
+#if defined(CONFIG_CMD_DHCP)
+#define BOOT_TARGET_DEVICES_DHCP(func)        func(DHCP, dhcp, na)
+#else
+#define BOOT_TARGET_DEVICES_DHCP(func)
+#endif
+
+#if defined(CONFIG_CMD_MMC)
+#define BOOT_TARGET_DEVICES_MMC(func) func(MMC, mmc, 0)
+#else
+#define BOOT_TARGET_DEVICES_MMC(func)
+#endif
+
+#if defined(CONFIG_CMD_UBIFS)
+#define BOOT_TARGET_DEVICE_UBIFS(func)        func(UBIFS, ubifs, 0, ubi, rootfs)
+#else
+#define BOOT_TARGET_DEVICE_UBIFS(func)
+#endif
+
+#if defined(CONFIG_MPFS_PRIORITISE_QSPI_BOOT)
+#define BOOT_TARGET_DEVICES(func) \
+      BOOT_TARGET_DEVICE_UBIFS(func)  \
+      BOOT_TARGET_DEVICES_MMC(func)\
+      BOOT_TARGET_DEVICES_DHCP(func)
+#else
+#define BOOT_TARGET_DEVICES(func) \
+      BOOT_TARGET_DEVICES_MMC(func)\
+      BOOT_TARGET_DEVICES_DHCP(func)
+#endif
+
+#define BOOTENV_DESIGN_OVERLAYS \
+      "design_overlays=" \
+      "if test -n ${no_of_overlays}; then " \
+              "setenv inc 1; " \
+              "setenv idx 0; " \
+              "fdt resize ${dtbo_size}; " \
+              "while test $idx -ne ${no_of_overlays}; do " \
+                      "setenv dtbo_name dtbo_image${idx}; " \
+                      "setenv fdt_cmd \"fdt apply $\"$dtbo_name; " \
+                      "run fdt_cmd; " \
+                      "setexpr idx $inc + $idx; " \
+              "done; " \
+      "fi;\0 " \
+
+#if !defined(CONFIG_FIT_SIGNATURE)
+#include <config_distro_bootcmd.h>
+
+#define CFG_EXTRA_ENV_SETTINGS \
+      "bootm_size=0x10000000\0" \
+      "kernel_addr_r=0x80200000\0" \
+      "fdt_addr_r=0x8a000000\0" \
+      "fdtoverlay_addr_r=0x8a080000\0" \
+      "ramdisk_addr_r=0x8aa00000\0" \
+      "scriptaddr=0x8e000000\0" \
+      BOOTENV_DESIGN_OVERLAYS \
+      BOOTENV \
+
+#endif
+#endif /* __CONFIG_H */

base-commit: d1543d9af995fe5013d7c32ec01ccaaeb16ce456
--
2.30.2

